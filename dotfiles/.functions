#!/bin/bash
#
# ~/.functions
#
# Requirements: None


### FUNTIONS DECLARATION

########################################
# Purpose:
#  ERROR HANDLING
# Usage:  
#  die
########################################

out() { printf "$1 $2\n" "${@:3}"; }
error() { out "==> ERROR:" "$@"; } >&2
warning() { out "==> WARNING:" "$@"; } >&2
msg() { out "==>" "$@"; }
msg2() { out "  ->" "$@";}
die() { error "$@"; exit 1; }

########################################
# Purpose:
#  function to test bash commands and
#  generate a file log when command files
# Dependencies: positional arguments = $@
# Usage:  
#  try <<command>>
########################################

# function try 
# {
#   set -o errtrace    # inherit any trap on ERROR
#   "$@"
#   set +o errtrace    # turn off the flag
# }

function try
{
    # set -o pipefail -e
    # set -o errexit
    set -o xtrace
    "$@"
    status=$?
    if [ $status -eq 1 ]; then
	# echo "ERROR in command: $@"
      (echo "ERROR in command: $@") 2>&1 | tee -a "$0".log
      die "please verify errors reported in ls $(${0}.log)"
    elif [ $status -eq 0 ]; then
	echo "..$@ ..command succeded"
    fi
    set +o xtrace
    # set +o errexit
    # set +o pipefail +e
}

########################################
# Purpose:
#  A function to redirect the stdout (1) stderror (2)
#  of a command to /dev/null
# Usage:  
#  nullify program arg1 arg2
########################################
function amiroot
{
  ROOT_UID=0   # Root has $UID 0.

  if [[ "$UID" -eq "$ROOT_UID" ]]; then
    echo "You are root."
  else
    echo "Root priviledges required. Cancelling"
    exit 0
  fi
}
########################################
# Purpose:
#  A function to redirect the stdout (1) stderror (2)
#  of a command to /dev/null
# Usage:  
#  nullify program arg1 arg2
########################################
function nullify 
{
  "$@" >/dev/null 2>&1
  # you can also use:
  # "$@" >& /dev/null
}


########################################
# Purpose: check internet connection and exit if offline
# Dependencies: None
########################################

function check_internet 
{ 
  # if internet offline, please exit
  if ! wget -q --spider http://google.com; then
    printf "ERROR in internet conection!, exiting %s\n" "${0}"
    sleep 3
    exit 0
  fi
} 


########################################
# Purpose: function to download AUR packages in /tmp and install them
# Usage:
# aur <package name or url>
########################################

function aur 
{
  ## run only if internet connection is available
  check_internet		

  ## check positional argument
  if (( "$#" -eq 0 )); then
    echo "$0 requires an argument, can be an aur package NAME or URL"
    sleep 3
    exit 0
  fi
  
  ##  FLASH FLAGS FOR SECURITY AND DEBUGGING
  # set -o errexit		# EXIT if script command fails
  # set -o xtrace			# trace & expand what gets executed

  ## complete the AUR URL if user provided only the package name
  if [[ ! "$1" == *"https://"* ]];then
    # set the value of $1
    try set -- "$(printf "https://aur.archlinux.org/%s.git" "$1")"
  fi

  ## check if user provided a valid git repo
  verify_if_git_repo_exists="$(git ls-remote $1 HEAD)"
  if (( "${#check_if_git_repo_exists}" -eq 0 )); then
    warning "Git repository not found or incorrect: \n%s\n" "$1"
    sleep 3
    exit 0
  fi

  ## check if AUR package is already on system
  package_name="$(basename $1 .git)"
  search_package_in_system="$(pacman -Qm ${package_name})"
  if [[ -n "${search_package_in_system}" ]]; then
    warning "AUR package %s is already on system\n" "${package_name}"
    sleep 3
    exit 0
  fi

  ## remove directory if previously present in /tmp
  [[ -d /tmp/"${package_name}" ]] && rm -rf /tmp/"${package_name}"

  ## install aur package after check it was not previously installed
  msg "installing AUR package %s\n" "${package_name}"
  try git clone "$1" /tmp/"${package_name}"
  try cd /tmp/"${package_name}"
  try makepkg -Ccsri --noconfirm --needed
  try cd "${OLDPWD}"
}


## dirsize - finds directory sizes & lists them for the current directory

function dirsize {
  du -shx * .[a-zA-Z0-9_]* 2> /dev/null \
    | egrep '^ *[0-9.]*[MG]' | sort -n > /tmp/list
  egrep '^ *[0-9.]*M' /tmp/list
  egrep '^ *[0-9.]*G' /tmp/list
  rm -rf /tmp/list
}


## extract compressed files

function extract
{
  if [[ -f "$1" ]]; then
    case "$1" in
      *.tar.bz2)   tar xvjf "$1"    ;;
      *.tar.gz)    tar xvzf "$1"    ;;
      *.bz2)       bunzip2 "$1"     ;;
      *.rar)       unrar x "$1"     ;;
      *.gz)        gunzip "$1"      ;;
      *.tar)       tar xvf "$1"     ;;
      *.tbz2)      tar xvjf "$1"    ;;
      *.tgz)       tar xvzf "$1"    ;;
      *.zip)       unzip "$1"       ;;
      *.Z)         uncompress "$1"  ;;
      *.7z)        7z x "$1"        ;;
      *)           echo "don't know how to extract '$1'..." ;;
    esac
  else
    echo "'$1' is not a valid file!"
  fi
}


## No more cd ../../../.. but up 4

function up
{
  local d=""
  limit="$1"
  for ((i=1 ; i <= limit ; i++))
  do
    d="${d}"/..
  done
  d=$(echo "${d}" | sed 's/^\\///')
  [[ -z "${d}" ]] && d=..
  cd "${d}"
}


## install plugins without open vim

function my_vim_install
{
  if [[ ! -d "~/.vim/plugged/jummidark.vim" ]]; then
    ## install plugins without open vim
    sleep 3
    vim -E -s -u $HOME/.vimrc +PlugInstall +visual +qall
  fi
}


## git config

function my_git_config
{
  if [[ ! -f "$HOME/.gitconfig" ]]; then
    cd "$HOME"
    if mount | grep -q shared; then
      bash "$HOME/shared/.gitrc" \
        || echo "ERROR: can not run script $_"
    elif mount | grep -q _EXT; then
      # automatic configuration
      bash "$(mount | awk '/_EXT/ {printf $3}')/.gitrc" \
        || echo "ERROR: can not run script $_"
    else
      # semiautomatic configuration
      printf "==> Set git GLOBAL configuration\n"
      read -p "--> Set git user name [$USER]: " git_username
      git config --global user.name "${git_username:-$USER}" \
	|| echo "ERROR: can not set git config user.name $_"
      usermail="raom2004@gmail.com"
      read -p "--> Set git user MAIL [$usermail]: " git_usermail
      git config --global user.mail "${git_usermail:-$usermail}" \
	   || echo "ERROR: can not set git config user.mail $_"
      read -p "--> Set git editor vim or emacs [vim]: " git_editor
      git config --global core.editor "${git_editor:-vim}" \
	|| echo "ERROR: can not set git config core.editor $_"
      read -p "--> Set git credential.helper [cache]: " git_cred
      git config --global credential.helper "${git_cred:-cache}" \
	   || echo "ERROR: can not set git config credential.helper $_"
    fi
    cd "$OLDPWD"
  fi
}


## do sudo, or sudo the last command if no argument given

function repeat
{
  if (( $# == 0 )); then
    sudo $(history -p '!!')
  else
    sudo "$@"
  fi
}


## create a backup file

function mybackup
{
  cp "$1" \
     ~/.backup/"$(basename \"${1}\")"-"$(date +%Y%m%d%H%M)".backup
}


## reduce typing for my own git repo

function mygit
{
  if [[ -z $1 ]]; then
    echo "mygit require the name of the repository"
  else
    git clone "https://github.com/raom2004/$1"
  fi
}


## automatize archlinux update

function update_archlinux
{
  printf "\n==> Updating archlinux keyring\n"
  try sudo pacman -Syy --noconfirm archlinux-keyring 
  printf "\n==> Updating archlinux pacman packages\n"
  try sudo pacman -Syu 
  printf "\n==> Updating archlinux AUR virtualbox extention\n"
  try aur 'https://aur.archlinux.org/virtualbox-ext-oracle.git'
  ## UPDATE XMONAD
  if grep 'Apple' /sys/devices/virtual/dmi/id/board_vendor; then
    printf "\n==> Recompiling xmonad\n"
    try xmonad --recompile
  fi
}


# emacs:
# Local Variables:
# sh-basic-offset: 2
# End:

# vim: set ts=2 sw=2 et:
