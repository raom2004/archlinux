#!/bin/zsh
#
# ~/.zsh_prompt
# source: https://gist.github.com/joshdick/4415470

setopt prompt_subst
autoload -U colors && colors # Enable colors in prompt

## GLOBA VARIABLES
# Modify the colors and symbols in these variables as desired.
GIT_PROMPT_BRANCH_COLOR="%{$fg_bold[magenta]%}"
GIT_PROMPT_MASTER_BRANCH_COLOR="%{$fg_bold[yellow]%}"
GIT_PROMPT_SEPARATOR=" %{$fg[white]%}|%{$reset_color%}"
GIT_PROMPT_PREFIX=" %{$fg[white]%}[%{$reset_color%}"
GIT_PROMPT_SUFFIX="%{$fg[white]%}]%{$reset_color%}"
GIT_PROMPT_AHEAD="%{$fg[red]%}⬆.NUM%{$reset_color%}"
GIT_PROMPT_BEHIND="%{$fg[cyan]%}⬇.NUM%{$reset_color%}"
GIT_PROMPT_MERGING="%{$fg[magenta]%}⚡︎%{$reset_color%}"
GIT_PROMPT_UNTRACKED=" %{$fg[cyan]%}…NUM%{$reset_color%}"
GIT_PROMPT_MODIFIED=" %{$fg[yellow]%}✚.NUM%{$reset_color%}"
GIT_PROMPT_STAGED=" %{$fg[green]%}●NUM%{$reset_color%}"
GIT_CONTAINING_FOLDER_COLOR="%{$fg_bold[yellow]%}"

# Show Git branch/tag, or name-rev if on detached head
parse_git_branch() {
  (git symbolic-ref -q HEAD || git name-rev --name-only --no-undefined --always HEAD) 2> /dev/null
}

# Show different symbols as appropriate for various Git repository states
parse_git_state() {

  # Compose this value via multiple conditional appends.
  local GIT_STATE=""

  local NUM_AHEAD="$(git log --oneline @{u}.. 2> /dev/null | wc -l | tr -d ' ')"
  if [ "$NUM_AHEAD" -gt 0 ]; then
    # replace NUM for $NUM_AHEAD
    GIT_STATE="$GIT_STATE${GIT_PROMPT_AHEAD//NUM/$NUM_AHEAD}"
  fi

  local NUM_BEHIND="$(git log --oneline ..@{u} 2> /dev/null | wc -l | tr -d ' ')"
  if [ "$NUM_BEHIND" -gt 0 ]; then
    # replace NUM for $NUM_BEHIND
    GIT_STATE="$GIT_STATE${GIT_PROMPT_BEHIND//NUM/$NUM_BEHIND}"
  fi

  local GIT_DIR="$(git rev-parse --git-dir 2> /dev/null)"
  if [ -n $GIT_DIR ] && test -r $GIT_DIR/MERGE_HEAD; then
    GIT_STATE="$GIT_STATE$GIT_PROMPT_MERGING"
  fi

  local NUM_MODIFIED="$(git diff --name-status 2> /dev/null | wc -l)"
  if [[ "$NUM_MODIFIED" -gt 0 ]]; then
    GIT_STATE="$GIT_STATE${GIT_PROMPT_MODIFIED//NUM/$NUM_MODIFIED}"
  fi

  local NUM_UNTRACKED="$(git ls-files --other --exclude-standard 2> /dev/null | wc -l)"
  if [[ "$NUM_UNTRACKED" -gt 0 ]]; then
    GIT_STATE="$GIT_STATE${GIT_PROMPT_UNTRACKED//NUM/$NUM_UNTRACKED}"
  fi

  local NUM_STAGED="$(git diff --cached --quiet | wc -l)"
  if [[ "$NUM_STAGED" -gt 0 ]]; then
    GIT_STATE="$GIT_STATE${GIT_PROMPT_STAGED//NUM/$NUM_STAGED}"
  fi


  if [[ -n "$GIT_STATE" ]]; then
    echo "$GIT_STATE"
  fi

}

git_prompt_string() {
  local git_where="$(parse_git_branch)"
  if [[ -n "${git_where}" ]]; then
    # this like converts git_where="refs/heads/master" to "master"
    local branch="${git_where#(refs/heads/|tags/)}"
    case "${branch}" in
      master)
	branch="${GIT_PROMPT_MASTER_BRANCH_COLOR}${branch}%{$reset_color%}"
	;;
      *)
	branch="${GIT_PROMPT_BRANCH_COLOR}${branch}%{$reset_color%}"
	;;
    esac
    # obtain fullpath /<rooth>/<GIT_CONTAINER_FOLDER>
    local git_container_folder_fullpath="$(git rev-parse --show-toplevel 2>/dev/null)"
    # obtain /<GIT_CONTAINER_FOLDER>
    local git_container_folder=$(basename $git_container_folder_fullpath 2> /dev/null)
    # obtain full path /<root>/<GIT_CONTAINER_FOLDER>/<git-subfolder>/
    local current_fullpath=$(pwd)
    # please show only the git directory tree, colored, before git prompt
    local git_directory_without_color=$git_container_folder${current_fullpath#$git_container_folder_fullpath}
    local git_directory="${GIT_CONTAINING_FOLDER_COLOR}${git_directory_without_color}%{$reset_color%}"

    echo "${git_directory}${GIT_PROMPT_PREFIX}${branch}${GIT_PROMPT_SEPARATOR}$(parse_git_state)${GIT_PROMPT_SUFFIX}"
  else
    echo "%~" # show pwd no color
  fi
}

# Set the right-hand prompt
# RPS1='$(git_prompt_string)'
# PS1='%F{cyan}%n%f@%M: %~%F{cyan}$(git_prompt_string)%f %# '
PS1='%F{cyan}%n%f@%M $(git_prompt_string) %# '


## zsh PS1 prompt customization
# PROMPT='%F{cyan}%n%f@%M: %~%F{cyan}${vcs_info_msg_0_}%f %# '

# ## add "git prompt" to PS1 prompt
# if [[ ! -f "$HOME/.zsh-git-prompt/zshrc.sh" ]]; then
#     git clone https://github.com/olivierverdier/zsh-git-prompt.git ~/.zsh-git-prompt --depth=1
# fi

# if [[ -f "$HOME/.zsh-git-prompt/zshrc.sh" ]]; then
#     source ~/.zsh-git-prompt/zshrc.sh
#     # an example prompt
#     PROMPT='%B%m%~%b$(git_super_status) %# '
# fi


# # function zle-line-init zle-keymap-select {
# #     RPS1="${${KEYMAP/vicmd/-- NORMAL --}/(main|viins)/-- INSERT --}"
# #     RPS2=$RPS1
# #     zle reset-prompt
# # }
# # zle -N zle-line-init
# # zle -N zle-keymap-select


# # TODO multiline zsh PS1 prompt
# #https://unix.stackexchange.com/questions/547/make-my-zsh-prompt-show-mode-in-vi-mode
# terminfo_down_sc=$terminfo[cud1]$terminfo[cuu1]$terminfo[sc]$terminfo[cud1]

# function insert-mode () { printf "[vi:ins] " }
# function command-mode () { printf "[vi:cmd] " }
# function emacs-mode () { printf "(Emacs) " }

# precmd () {
#     # yes, I actually like to have a new line, then some stuff and then 
#     # the input line
# #     print -rP "
# # [%D{%a, %d %b %Y, %H:%M:%S}] %n %{$fg[blue]%}%m%{$reset_color%}"

#     # this is required for initial prompt and a problem I had with Ctrl+C or
#     # Enter when in normal mode (a new line would come up in insert mode,
#     # but normal mode would be indicated)
#     PS1="%{$terminfo_down_sc$(insert-mode)$terminfo[rc]%}%~ $ "
# }

# function set-prompt () {
#     case ${KEYMAP} in
#       (vicmd)      VI_MODE="$(command-mode)" ;;
#       (main|viins) VI_MODE="$(insert-mode)" ;;
#       (emacs)      VI_MODE="$(emacs-mode)" ;;
#     esac
#     # PS1="%n@%m%{$terminfo_down_sc$VI_MODE$terminfo[rc]%}%~ $ "
#     PS1="${VI_MODE}${cyan}%n${reset_color}@%m%{$terminfo_down_sc%}%~ $ "
# }

# function zle-line-init zle-keymap-select {
#     set-prompt
#     zle reset-prompt
# }
# preexec () { print -rn -- $terminfo[el]; }

# zle -N zle-line-init
# zle -N zle-keymap-select


# emacs:
# Local Variables:
# sh-basic-offset: 2
# End:

# vim: set ts=2 sw=2 et:
