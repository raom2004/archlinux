#+startup: showeverything nohideblocks inlineimages
#+options: creator:nil author:nil toc:t date:t email:nil num:nil title:nil \n:t
#+title: README
#+date: <2022-01-03 Mon>
#+author: Ricardo A. O. Medina
#+email: raom2004@gmail.com
#+language: en
#+creator: Emacs 27.2 (Org mode 9.3.7)

* Arch Linux: automating installation scripts

* Intro

Arch Linux is a minimalist and flexible Linux distribution which excellent documentation and high-quality packages allow users to design a highly customized system. A philosophy opposite to Linux beginner-friendly distributions which provides a pre-configured system with packages that are unnecessary or designed for user data collection (e.g. Ubuntu and Canonical's commercial nature).

#+HTML:<div align=center>
#+CAPTION: archlinux-Ubuntu/Canonical
#+NAME: Fig. 1
[[./.images/arch-linux-vs-ubuntu.png]]
#+HTML:</div>

Arch Linux encourage users to install packages that fulfill their unique needs, obtaining a lightweight and incredibly powerful system, easy to manage. However, the installation and configuration process can be challenging for beginners, specially when the documentation have not been extensively read. 

But what to do once someone has completed Arch Linux install? 

*You can automatize the Arch Linux installation using the scripts described in this repository*, with tips and recommendations from the official documentation and forums, useful for: 
 - Everyone who has installed Arch Linux before and wants to automatize the process using scripts.
 - Someone who has not installed Arch Linux before but definitely wants to have a look over the commands required.
In both cases, this repository is definitely for you!

* Content
#+begin_quote
 - [[Automated installation scripts - example]]
 - [[Advanced aspects]]
   - [[Disk partitioning BIOS/MBR, BIOS/GPT, UEFI/GPT and their encryption]]
   - [[Packages installing with pacstrap and the importance of keyring update]]
   - [[TODO User data encryption]]
   - [[TODO System backup, user documents backup and system update]]
   - [[TODO Security and documents encryption]]
#+end_quote

* Automated installation scripts - example

The most easy example to automatize the Arch Linux install, consist in 3 scripts for specific tasks.

**** The [[./script1.sh][script1.sh]] performs the critical pre-installation steps, such as:
  #+begin_quote
  - Disk partitioning and formatting with =parted=
  - partitions mounting
  - Package installation with =pacstrap=
  #+end_quote

**** The [[./script2.sh][script2.sh]] setup the new Arch Linux system using =chroot=, to configure:
  #+begin_quote
  - Locale and datetime
  - The keyboard keymap
  - The preferred shell, like =bash= or =zsh=
  - the initial ram filesystem, =initramfs=
  - User accounts, passwords and permissions, including =sudo=
  - The installation of the boot loader =grub=
  #+end_quote

**** The [[./script2.sh][script3.sh]] runs on *first desktop boot*, to setup:
  #+begin_quote
  - The user configuration files (also known as =dotfiles=)
  - The desktop customizations itself
  #+end_quote

This is an easy approach to install Arch Linux using scripts. It is quite useful for *testing* and *debugging* new Arch Linux configurations, dotfiles and desktop customizations, preferably *inside a virtual machine*. In next chapter we will talk about Arch Linux install in real Machines.

* Advanced aspects

Install Arch Linux in real machines usually need to address some advanced aspects, like disk partitioning according to the firmware available (UEFI, BIOS), partition tables (MBR, GPT), boot support for additional operative systems, user data or system encryption, and last but not least, Arch Linux backup and maintenance. 

**** In this regard, this chapter covers recommendations about:
#+begin_quote
- Disk partitioning BIOS/MBR, BIOS/GPT, UEFI/GPT and their encryption
- Installing packages with pacstrap and the importance of keyring update
- User data encryption
- How to make a backup of the entire system, and make it bootable too
- Arch Linux maintenance using maint
#+end_quote


** Disk partitioning BIOS/MBR, BIOS/GPT, UEFI/GPT and their encryption

This chapter cover the most standard disk partitioning tables using =parted= and the bootloader =GRUB=.

*** BIOS/MBR

Arch Linux, as any other linux distro, only precise one unique partition, the single root partition =/=.

The example of BIOS/MBR disk partitioning table, is:

#+begin_src bash :results verbatim
## HDD partitioning (BIOS/MBR)
parted -s /dev/sda mklabel msdos
parted -s -a optimal /dev/sda mkpart primary ext4 0% 100%
parted -s /dev/sda set 1 boot on

## HDD formating (-F: overwrite if necessary)
mkfs.ext4 -F /dev/sda1

## HDD mounting
mount /dev/sda1 /mnt 
#+end_src

*** BIOS/GPT

Contrary to BIOS/MBR, a BIOS/GPT disk partitioning table, requires:
#+begin_quote
- A table partitioning =gpt= instead of =msdos="
- A BIOS boot partition (which do not require to be mounted)
- The flag =bios_grub= instead of =boot=
#+end_quote

The example of BIOS/GPT disk partitioning table, is:

#+begin_src bash :results verbatim
## HDD partitioning (BIOS/GPT)
parted -s /dev/sda mklabel gpt
parted -s -a optimal /dev/sda mkpart primary ext2 0% 2MiB
parted -s /dev/sda set 1 bios_grub on
parted -s -a optimal /dev/sda mkpart primary ext4 2MiB 100%

## HDD formating (-F: overwrite if necessary)
mkfs.ext4 -F /dev/sda2

## HDD mounting
# BIOS/GPT require space for the partition bios_grub
# but such boot partition don't require to be mounted
mount /dev/sda2 /mnt
#+end_src

*** UEFI/GPT

The UEFI/GPT partition table is similar to the previous, with few modifications:
#+begin_quote
- A boot partition with =fat32= as the file system type
- The flag =esp= instead of =bios_grub=
- Install the =efibootmbr= package
#+end_quote

The example of UEFI/GPT disk partitioning table, is:

#+begin_src bash :results verbatim
## HDD partitioning (UEFI/GPT)
parted -s /dev/sda mklabel gpt
parted -s -a optimal /dev/sda mkpart primary 0% 512MiB
parted -s /dev/sda set 1 esp on
parted -s -a optimal /dev/sda mkpart primary 512MiB 100%

## HDD formating (-F: overwrite if necessary)
mkfs.fat -F32 /dev/sda1
mkfs.ext4 -F /dev/sda2

## HDD mounting
mount /dev/sda2 /mnt
mkdir -p /mnt/boot/efi
mount /dev/sda1 /mnt/boot/efi
#+end_src

#+begin_src bash :results verbatim
## install package required for GRUB to boot in UEFI mode
if [[ ${boot_mode} == "UEFI" ]]; then
    pacstrap /mnt efibootmgr	 
fi
#+end_src

*** Disk partitioning, all together

What happen when we want to support the options mentioned? In such case, Arch Linux can detect if it has booted from =BIOS= or =UEFI=, which can be quite useful to make a conditional like this:

#+begin_src bash :results verbatim
# BIOS and UEFI support
if ! ls /sys/firmware/efi/efivars >& /dev/null; then
    boot_mode="BIOS"
else
    boot_mode="UEFI"
fi


if [[ ${boot_mode} == "BIOS" ]]; then
    printf "BIOS detected! you can select a GPT or MBR partition table:\n"
    select OPTION in MBR GPT; do
	case ${OPTION} in
	    MBR)
		## HDD partitioning (BIOS/MBR)
		parted -s /dev/sda mklabel msdos
		parted -s -a optimal /dev/sda mkpart primary ext4 0% 100%
		parted -s /dev/sda set 1 boot on
		
		## HDD formating (-F: overwrite if necessary)
		mkfs.ext4 -F /dev/sda1

		## HDD mounting
		mount /dev/sda1 /mnt
		break
		;;
	    GPT)
		## HDD partitioning (BIOS/GPT)
		parted -s /dev/sda mklabel gpt
		parted -s -a optimal /dev/sda mkpart primary ext2 0% 2MiB
		parted -s /dev/sda set 1 bios_grub on
		parted -s -a optimal /dev/sda mkpart primary ext4 2MiB 100%
		
		## HDD formating (-F: overwrite if necessary)
		mkfs.ext4 -F /dev/sda2
		
		## HDD mounting
		mount /dev/sda2 /mnt
		break
		;;
	esac
    done
fi


if [[ ${boot_mode} == "UEFI" ]]; then
    ## HDD partitioning (UEFI/GPT)
    parted -s /dev/sda mklabel gpt
    parted -s -a optimal /dev/sda mkpart primary 0% 512MiB
    parted -s /dev/sda set 1 esp on
    parted -s -a optimal /dev/sda mkpart primary 512MiB 100%

    ## HDD formating (-F: overwrite if necessary)
    mkfs.fat -F32 /dev/sda1
    mkfs.ext4 -F /dev/sda2

    ## HDD mounting
    mount /dev/sda2 /mnt
    mkdir -p /mnt/boot/efi
    mount /dev/sda1 /mnt/boot/efi
fi

## package required for GRUB to boot in UEFI mode
if [[ ${boot_mode} == "UEFI" ]]; then
    pacstrap /mnt efibootmgr	 
fi
#+end_src

*** Encrypted partitioning with LUKS and LVM

After explain some examples of the most standard disk partitioning schemes, it is important to mentioned that disk partitioning can be completely encrypted. This specific item have been very well described [[https://www.rohlix.eu/post/linux-disk-encryption-with-bios-uefi-using-mbr-gpt-luks-lvm-and-grub/][here]].

In summary, this chapter described few but relevant aspects about the disk partitioning according to the boot loader =GRUB=. The disk partitioning tables described here works quite well, but you can add other partitions to these examples, taking extra care to avoid an Arch Linux install unable to boot.

The examples were made with the boot loader =GRUB= because it supports [[https://wiki.archlinux.org/title/Arch_boot_process#Boot_loader][almost everything]], like different firmwares, partition tables, multi-boot, file systems, RAID and LVM and their encryption, in addition to the documentation and forums available.

** Installing packages with pacstrap and the importance of keyring update

The first pacstrap that I wrote, looked like this:

#+begin_src bash :results verbatim
## install system packages (with support for wifi and ethernet)
pacstrap /mnt base base-devel linux \
	 zsh sudo vim git wget \
	 dhcpcd \
	 networkmanager \
	 grub os-prober \
	 xorg-server lightdm lightdm-gtk-greeter \
	 gnome-terminal terminator cinnamon livecd-sounds \
	 firefox \
	 virtualbox-guest-utils
#+end_src

This code has two important problems:
#+begin_quote
- No comments about the purpose of each package. 
- An outdated Linux installation image can prompt an error about gpg keyring. 
#+end_quote
For the previously mentioned, I started to use a different approach, like this:

#+begin_src bash :results verbatim
## Update package manager to avoid gpg keyrong errors
pacman -Syy --noconfirm archlinux-keyring


## Install System Elementary Packages
# esential packages
pacstrap /mnt base base-devel linux
# code editors
pacstrap /mnt vim nano
# system shell	
pacstrap /mnt zsh
# system shell additional functions
pacstrap /mnt pkgfile
# system tools	
pacstrap /mnt sudo git wget
# support for file system mounting
pacstrap /mnt gvfs
# system backup	
pacstrap /mnt rsync
# network package
pacstrap /mnt dhcpcd
# wifi package
pacstrap /mnt networkmanager
# boot loader	
pacstrap /mnt grub
# boot loader support for additional operative systems
pacstrap /mnt os-prober
# boot loader support to boot in UEFI mode (required for GRUB)
if [[ "${boot_mode}" == "UEFI" ]]; then
    pacstrap /mnt efibootmgr
fi
#+end_src

In the example above the repeated use of pacstrap can be abusive, but this way it looks more readable and maintainable too. Indeed, it is easy to note that an essential package is missing for Arch Linux installation in any real machine:

#+begin_src bash :results verbatim
pacstrap /mnt linux-firmware
#+end_src


** User data encryption
** How to make a backup of the entire system, and make it bootable too
*** Arch Linux maintenance using maint

