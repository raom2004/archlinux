#+startup: showeverything nohideblocks inlineimages
#+options: creator:nil author:nil toc:t date:t email:nil num:nil title:nil \n:t
#+title: README
#+date: <2022-01-03 Mon>
#+author: Ricardo A. O. Medina
#+email: raom2004@gmail.com
#+language: en
#+creator: Emacs 27.2 (Org mode 9.3.7)

* Arch Linux: automating installation scripts

*Arch Linux* is a minimalist and flexible Linux distribution which excellent documentation and high-quality packages that *allow users to design a highly customized system*. A philosophy *opposite to Linux beginner-friendly distributions* which provides a pre-configured system with packages that are unnecessary or *designed for user data collection* (e.g. Ubuntu and Canonical's commercial nature).

#+HTML:<div align=center>
#+CAPTION: archlinux-Ubuntu/Canonical
#+NAME: Fig. 1
[[./.images/arch-linux-vs-ubuntu.png]]
#+HTML:</div>

Arch Linux philosophy encourage users to select packages that fulfill their unique needs, obtaining an incredibly powerful and lightweight system, easy to manage. However, the installation and configuration process can be challenging for beginners, specially when the documentation have not been extensively read.

This repository summarizes tips and recommendations to *automate Arch Linux installation* using scripts based in the official documentation and Arch Linux forums.

This way, if you want to automate the Arch Linux installation but you are not sure how achieve this using scripts? well, this repo contains all you need to achieve it!

But what Haven't you installed Arch Linux before? don't panic, you will definitely find this repository useful because it allows you to have a look over the commands required to install and configure Arch Linux.

** Content
 #+begin_quote
 - [[Intro]]
   - [[Who may read this repository?]]
 - [[Arch Linux - automated installation scripts]]
 - [[Improving the automated installation scripts]]
   - [[Disk partitioning BIOS/MBR, BIOS/GPT, UEFI/GPT and their encryption]]
   - [[BIOS/MBR]]
   - [[BIOS/GPT]]
   - [[UEFI/GPT]]
   - [[Disk partitioning, all together - BIOS/MBR, BIOS/GPT and UEFI/GPT]]
   - [[Advance disk partitioning - encrypted partitioning with LUKS LVM]]
 - [[Packages installing with pacstrap and the importance of keyring update]]
 - [[TODO User data encryption]]
 - [[TODO System backup, user documents backup and system update]]
 - [[TODO Security and documents encryption]]
 #+end_quote



*** Who may read this repository?


** Arch Linux - automated installation scripts

The easiest version to install Arch Linux by shell commands, requires only 3 scripts:

- [[./script1.sh][script1.sh]] - perform the critical pre-installation steps, such as:
  - Disk partitioning and formatting with =parted=, as well as partition mounting
  - Package installation with =pacstrap=

- [[./script2.sh][script2.sh]] - setup the new Arch Linux system using =chroot=, for:
  - Config locale and datetime
  - create the initial ram filesystem =initramfs=
  - Config User accounts, passwords and permissions, including =sudo=
  - keymap
  - Set a preferred shell, like =bash= or =zsh=
  - Install a boot loader =grub=

- [[./script3.sh][script3.sh]] - is a script that will run on *first desktop boot*, able to:
  - Set user configuration files (also known as =dotfiles=)
  - Set the desktop customizations itself

IMHO, this approach is the easiest example of how-to install Arch Linux using scripts. It is useful for *test* and *debugging* new Arch Linux configurations, dotfiles or desktop customizations, preferably *in a virtual machine*.

** Improving the automated installation scripts

Once you understand how to install Arch Linux inside a virtual machine, the next natural step is to *install Arch Linux in a Real Machine*. During such process, some relevant aspects must need to be addressed, like disk partitioning table according to hardware requirements, booting support for preexistent operative systems, system encryption, user data encryption, and the most relevant aspects in Arch Linux, backup an maintenance. 

In this regard, this chapter covers some of the aspects mentioned, such as:
- Disk partitioning BIOS/MBR, BIOS/GPT, UEFI/GPT and their encryption
- Package installing with pacstrap and the importance of keyring update
- User data encryption
- How to backup the entire system, and make it bootable too
- Arch Linux maintenance: maint


*** Disk partitioning BIOS/MBR, BIOS/GPT, UEFI/GPT and their encryption

This chapter cover the most standard disk partitioning schemes using =parted= and the bootloader =GRUB=.

**** BIOS/MBR

Arch Linux, as any other linux distro, only precise one unique partition, the single root partition =/=.

The example of such BIOS/MBR disk partitioning, is:

#+begin_src bash :results verbatim
## HDD partitioning (BIOS/MBR)
parted -s /dev/sda mklabel msdos
parted -s -a optimal /dev/sda mkpart primary ext4 0% 100%
parted -s /dev/sda set 1 boot on

## HDD formating (-F: overwrite if necessary)
mkfs.ext4 -F /dev/sda1

## HDD mounting
mount /dev/sda1 /mnt 
#+end_src

**** BIOS/GPT

If you want to support BIOS/GPT, you will need some changes according to the boot loader, which in this case is GRUB:
- Change the table partitioning from =msdos= to =gpt=
- GPT require a BIOS boot partition (that don't require to be mounted)
- Replace the =boot= flag for =bios_grub=

The example of BIOS/GPT partitioning table, is:

#+begin_src bash :results verbatim
## HDD partitioning (BIOS/GPT)
parted -s /dev/sda mklabel gpt
parted -s -a optimal /dev/sda mkpart primary ext2 0% 2MiB
parted -s /dev/sda set 1 bios_grub on
parted -s -a optimal /dev/sda mkpart primary ext4 2MiB 100%

## HDD formating (-F: overwrite if necessary)
mkfs.ext4 -F /dev/sda2

## HDD mounting
# BIOS/GPT require space for the partition bios_grub
# but such boot partition don't require to be mounted
mount /dev/sda2 /mnt
#+end_src

**** UEFI/GPT

The UEFI/GPT partition table is similar to the previous, with just few modifications:
- Create a boot partition with fat32 as the file system type
- Replace the =bios_grub= flag for =esp=
- Install package =efibootmbr= with pacstrap

The example of UEFI/GPT partitioning table, is:

#+begin_src bash :results verbatim
## HDD partitioning (UEFI/GPT)
parted -s /dev/sda mklabel gpt
parted -s -a optimal /dev/sda mkpart primary 0% 512MiB
parted -s /dev/sda set 1 esp on
parted -s -a optimal /dev/sda mkpart primary 512MiB 100%

## HDD formating (-F: overwrite if necessary)
mkfs.fat -F32 /dev/sda1
mkfs.ext4 -F /dev/sda2

## HDD mounting
mount /dev/sda2 /mnt
mkdir -p /mnt/boot/efi
mount /dev/sda1 /mnt/boot/efi
#+end_src

#+begin_src bash :results verbatim
## package required for GRUB to boot in UEFI mode
if [[ ${boot_mode} == "UEFI" ]]; then
    pacstrap /mnt efibootmgr	 
fi
#+end_src

**** Disk partitioning, all together - BIOS/MBR, BIOS/GPT and UEFI/GPT

What happen when we want to support the options mentioned?. Well, Arch Linux can detect if have booted from =BIOS= or =UEFI=, which can be quite useful to make a conditional like this:

#+begin_src bash :results verbatim
# BIOS and UEFI support
if ! ls /sys/firmware/efi/efivars >& /dev/null; then
    boot_mode="BIOS"
else
    boot_mode="UEFI"
fi


if [[ ${boot_mode} == "BIOS" ]]; then
    printf "BIOS detected! you can select a GPT or MBR partition table:\n"
    select OPTION in MBR GPT; do
	case ${OPTION} in
	    MBR)
		## HDD partitioning (BIOS/MBR)
		parted -s /dev/sda mklabel msdos
		parted -s -a optimal /dev/sda mkpart primary ext4 0% 100%
		parted -s /dev/sda set 1 boot on
		
		## HDD formating (-F: overwrite if necessary)
		mkfs.ext4 -F /dev/sda1

		## HDD mounting
		mount /dev/sda1 /mnt
		break
		;;
	    GPT)
		## HDD partitioning (BIOS/GPT)
		parted -s /dev/sda mklabel gpt
		parted -s -a optimal /dev/sda mkpart primary ext2 0% 2MiB
		parted -s /dev/sda set 1 bios_grub on
		parted -s -a optimal /dev/sda mkpart primary ext4 2MiB 100%
		
		## HDD formating (-F: overwrite if necessary)
		mkfs.ext4 -F /dev/sda2
		
		## HDD mounting
		mount /dev/sda2 /mnt
		break
		;;
	esac
    done
fi


if [[ ${boot_mode} == "UEFI" ]]; then
    ## HDD partitioning (UEFI/GPT)
    parted -s /dev/sda mklabel gpt
    parted -s -a optimal /dev/sda mkpart primary 0% 512MiB
    parted -s /dev/sda set 1 esp on
    parted -s -a optimal /dev/sda mkpart primary 512MiB 100%

    ## HDD formating (-F: overwrite if necessary)
    mkfs.fat -F32 /dev/sda1
    mkfs.ext4 -F /dev/sda2

    ## HDD mounting
    mount /dev/sda2 /mnt
    mkdir -p /mnt/boot/efi
    mount /dev/sda1 /mnt/boot/efi
fi

## package required for GRUB to boot in UEFI mode
if [[ ${boot_mode} == "UEFI" ]]; then
    pacstrap /mnt efibootmgr	 
fi
#+end_src


# The objective: 

# Install an Arch Linux system configuring dotfiles and desktop by bash scripts. 

# This text include how-to install Arch Linux in internal drive, but also in USB external removable media, called also USB persistent installation.

# How we will get there? Covering the next items:

# - Pre-installation, steps to prepare the new system
# - Installation, selecting the most relevant packages
# - Configuration, from file system table to boot loader config
# - Post-installation, using dotfiles and a lightweight desktop (xfce)

# Important: this text do not cover how-to prepare an installation
# medium like an USB flash drive, but you can find it [[https://wiki.archlinux.org/title/USB_flash_installation_medium][here]].

**** Advance disk partitioning - encrypted partitioning with LUKS LVM

After explain some examples of the most standard disk partitioning schemes, it is important to mentioned that disk partitioning can be completely encrypted. This specific item have been very well described [[https://www.rohlix.eu/post/linux-disk-encryption-with-bios-uefi-using-mbr-gpt-luks-lvm-and-grub/][here]].

*** Packages installing with pacstrap and the importance of keyring update

The first pacstrap that I wrote, looked like this:

#+begin_src bash :results verbatim
## install system packages (with support for wifi and ethernet)
pacstrap /mnt base base-devel linux \
	 zsh sudo vim git wget \
	 dhcpcd \
	 networkmanager \
	 grub os-prober \
	 xorg-server lightdm lightdm-gtk-greeter \
	 gnome-terminal terminator cinnamon livecd-sounds \
	 firefox \
	 virtualbox-guest-utils
#+end_src

The problem with this approach is that is not easy to comment the function of each package. I also found an additional problem when the archlinux install image is old enough to prompt an error about gpg keyring. For this reason I started to use a different approach, like this:

#+begin_src bash :results verbatim
## Important: update package manager keyring before install packages
pacman -Syy --noconfirm archlinux-keyring


## Install System Elementary Packages
# esential packages
pacstrap /mnt base base-devel linux
# code editors
pacstrap /mnt vim nano
# system shell	
pacstrap /mnt zsh
# system shell additional functions
pacstrap /mnt pkgfile
# system tools	
pacstrap /mnt sudo git wget
# system tools for file system mounting
pacstrap /mnt gvfs
# system backup	
pacstrap /mnt rsync
# network package
pacstrap /mnt dhcpcd
# wifi package
pacstrap /mnt networkmanager
# boot loader	
pacstrap /mnt grub os-prober
# boot loader package to boot GRUB if UEFI mode
if [[ ${boot_mode} == "UEFI" ]]; then
    pacstrap /mnt efibootmgr
fi
#+end_src

In the example above the overuse of pacstrap can be abusive, I am agree, but this way it looks more readable and maintainable too. Indeed, it is easy to note that an essential package is missing for Arch Linux installation in any real machine:

#+begin_src bash :results verbatim
pacstrap /mnt linux-firmware
#+end_src

# This list what is called "elementary packages", a minimun Arch Linux packages that allow to connect to internet, mount usb drivers, and make the boot loader to recognize other operating systems previously installed, like MS Windows, MacOS or even other Linux present. If you need to mount a HDD formated for MS Windows, you will need also other packages, such as:

# #+begin_src bash :results verbatim
# pacstrap /mnt ntfs-3g 
# #+end_src

*** TODO User data encryption

*** TODO System backup, user documents backup and system update

*** TODO Security and documents encryption

