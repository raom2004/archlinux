#+startup: showeverything nohideblocks inlineimages
#+title: README
#+date: <2022-01-03 Mon>
#+author: Ricardo A. O. Medina
#+email: raom2004@gmail.com
#+language: en
#+creator: Emacs 27.2 (Org mode 9.3.7)

* Arch Linux 

Arch Linux is a minimalist and flexible Linux distribution, which excellent documentation and high-quality packages that allow users to design a highly customized system. A philosophy opposite to *Linux beginner-friendly distributions* which provides a pre-configured system with packages that can be unnecessary, or designed for user data collection (e.g. Ubuntu and Canonical's commercial nature).

#+HTML:<div align=center>
#+CAPTION: archlinux-Ubuntu/Canonical
#+NAME: Fig. 1
[[./images/arch-linux-vs-ubuntu.png]]
#+HTML:</div>

Arch Linux philosophy encourage users to select packages that fits their unique needs, obtaining a lightweight powerful system, easy to manage. However, the installation process, configuration and debugging, can be challenging for beginners, specially when the documentation have not being extensively read.

For this reason, this repository summarizes the tips and recommendations to install and customize Arch Linux systems using bash scripts, based in the official documentation and the information available on internet.

** Who may read this repository?

If you have installed Arch Linux before following the official guide, congratulations because is not an easy process! But what now? well, you can repeat the process this time understanding how to put your code adequately in bash scripts, in such case, this repository is definitely for you!

But what if you haven't installed Arch Linux before? well you will definitely find this repository useful because it allows you to have a look over the commands required to install and configure Arch Linux.

** Install Arch Linux using scripts: the easy version

The most easy version to install Arch Linux by bash commands, requires only 3 scripts:

[[./script1.sh][script1.sh]]
To perform the critical pre-installation steps, such as:
  - Disk partitioning, formatting and mounting
  - Package installation with =pacstrap=

[[./script2.sh][script2.sh]] 
To setup the new Arch Linux system using =arch-chroot=, for:
  - Locale config
  - Time
  - Initramfs
  - Accounts and passwords
  - sudo
  - keymap
  - The preferred shell (e.g. bash or zsh)
  - Install a boot loader 

[[./script3.sh][script3.sh]] 
A script that run on *first desktop boot*, to:
  - Set user configuration files (also known as =dotfiles=)
  - Set the desktop customizations itself

This approach is the easiest example of how-to install Arch Linux using scripts. It is useful for *test* and *debugging* new install configurations, dotfiles or changes in desktop customization preferably *in a virtual machine*.

** Install Arch Linux using scripts: the advance version

As mentioned before a first Arch Linux installation is not easy, but once you understand the process inside a virtual machine, the next natural step is to *install Arch Linux in a Real Machine*. 

In this regard, this chapter covers important aspects related to:
- Disk partitioning BIOS/MBR, BIOS/GPT, UEFI/GPT and their encryption
- Package install with pacstrap and keyring update
- Boot loader common mistakes
- System backup, user documents backup and system update
- Security and documents encryption


*** Disk partitioning BIOS/MBR, BIOS/GPT, UEFI/GPT and their encryption

This chapter cover the most standard disk partitioning schemes using =parted= and the bootloader =GRUB=.

**** BIOS/MBR

In basic terms, Arch Linux as any other linux distro, can be installed and only precise one unique partition, the single root partition "/".

The most simple example of BIOS/MBR disk partitioning, is:

#+begin_src bash :results verbatim
## HDD partitioning (BIOS/MBR)
parted -s /dev/sda mklabel msdos
parted -s -a optimal /dev/sda mkpart primary ext4 0% 100%
parted -s /dev/sda set 1 boot on

## HDD formating (-F: overwrite if necessary)
mkfs.ext4 -F /dev/sda1

## HDD mounting
mount /dev/sda1 /mnt 
#+end_src

**** BIOS/GPT

If you want to make the same but with support for BIOS/GPT, you will need some changes according to the boot loader, which in this case is GRUB:
- Change the table partitioning from "msdos" (MBR) to "gpt"
- GPT require a BIOS boot partition
- Replace the "boot" flag for "bios_grub"

The example of BIOS/GPT partitioning table, is:

#+begin_src bash :results verbatim
## HDD partitioning (BIOS/GPT)
parted -s /dev/sda mklabel gpt
parted -s -a optimal /dev/sda mkpart primary ext2 0% 2MiB
parted -s /dev/sda set 1 bios_grub on
parted -s -a optimal /dev/sda mkpart primary ext4 2MiB 100%

## HDD formating (-F: overwrite if necessary)
mkfs.ext4 -F /dev/sda2

## HDD mounting
# BIOS/GPT require space for the partition bios_grub
# but only require to mount the root partition "/"
mount /dev/sda2 /mnt
#+end_src

**** UEFI/GPT

The UEFI/GPT partition table is similar to the previous, with just few modifications:
- Create a boot partition with fat32 as the file system type
- Replace the "bios_grub" flag for "esp"
- Install package "efibootmbr" with pacstrap

The example of UEFI/GPT partitioning table, is:

#+begin_src bash :results verbatim
## HDD partitioning (UEFI/GPT)
parted -s /dev/sda mklabel gpt
parted -s -a optimal /dev/sda mkpart primary 0% 512MiB
parted -s /dev/sda set 1 esp on
parted -s -a optimal /dev/sda mkpart primary 512MiB 100%

## HDD formating (-F: overwrite if necessary)
mkfs.fat -F32 /dev/sda1
mkfs.ext4 -F /dev/sda2

## HDD mounting
mount /dev/sda2 /mnt
mkdir -p /mnt/boot/efi
mount /dev/sda1 /mnt/boot/efi
#+end_src

#+begin_src bash :results verbatim
## package required for GRUB to boot in UEFI mode
if [[ ${boot_mode} == "UEFI" ]]; then
    pacstrap /mnt efibootmgr	 
fi
#+end_src

**** Disk partitioning, all together: BIOS/MBR, BIOS/GPT and UEFI/GPT

What happen when we want to support the options mentioned?. Well, Arch Linux can detect if have booted from BIOS or UEFI, which can be quite useful to make a conditional like this:

#+begin_src bash :results verbatim
# BIOS and UEFI support
if ! ls /sys/firmware/efi/efivars >& /dev/null; then
    boot_mode="BIOS"
else
    boot_mode="UEFI"
fi


if [[ ${boot_mode} == "BIOS" ]]; then
    printf "BIOS detected! you can select a GPT or MBR partition table:\n"
    select OPTION in MBR GPT; do
	case ${OPTION} in
	    MBR)
		## HDD partitioning (BIOS/MBR)
		parted -s /dev/sda mklabel msdos
		parted -s -a optimal /dev/sda mkpart primary ext4 0% 100%
		parted -s /dev/sda set 1 boot on
		
		## HDD formating (-F: overwrite if necessary)
		mkfs.ext4 -F /dev/sda1

		## HDD mounting
		mount /dev/sda1 /mnt
		break
		;;
	    GPT)
		## HDD partitioning (BIOS/GPT)
		parted -s /dev/sda mklabel gpt
		parted -s -a optimal /dev/sda mkpart primary ext2 0% 2MiB
		parted -s /dev/sda set 1 bios_grub on
		parted -s -a optimal /dev/sda mkpart primary ext4 2MiB 100%
		
		## HDD formating (-F: overwrite if necessary)
		mkfs.ext4 -F /dev/sda2
		
		## HDD mounting
		mount /dev/sda2 /mnt
		break
		;;
	esac
    done
fi


if [[ ${boot_mode} == "UEFI" ]]; then
    ## HDD partitioning (UEFI/GPT)
    parted -s /dev/sda mklabel gpt
    parted -s -a optimal /dev/sda mkpart primary 0% 512MiB
    parted -s /dev/sda set 1 esp on
    parted -s -a optimal /dev/sda mkpart primary 512MiB 100%

    ## HDD formating (-F: overwrite if necessary)
    mkfs.fat -F32 /dev/sda1
    mkfs.ext4 -F /dev/sda2

    ## HDD mounting
    mount /dev/sda2 /mnt
    mkdir -p /mnt/boot/efi
    mount /dev/sda1 /mnt/boot/efi
fi

## package required for GRUB to boot in UEFI mode
if [[ ${boot_mode} == "UEFI" ]]; then
    pacstrap /mnt efibootmgr	 
fi
#+end_src


The objective: 

Install an Arch Linux system configuring dotfiles and desktop by bash scripts. 

# This text include how-to install Arch Linux in internal drive, but also in USB external removable media, called also USB persistent installation.

How we will get there? Covering the next items:

- Pre-installation, steps to prepare the new system
- Installation, selecting the most relevant packages
- Configuration, from file system table to boot loader config
- Post-installation, using dotfiles and a lightweight desktop (xfce)

Important: this text do not cover how-to prepare an installation
medium like an USB flash drive, but you can find it [[https://wiki.archlinux.org/title/USB_flash_installation_medium][here]].

**** Advance disk partitioning: encrypted partitioning with LUKS LVM

After explain some examples of the most standard disk partitioning schemes, it is important to mentioned that disk partitioning can be completely encrypted. This specific item have been very well described [[https://www.rohlix.eu/post/linux-disk-encryption-with-bios-uefi-using-mbr-gpt-luks-lvm-and-grub/][here]].

*** Install essential packages with pacstrap and the keyring update

The first pacstrap that I wrote, looked like this:

#+begin_src bash :results verbatim
## install system packages (with support for wifi and ethernet)
pacstrap /mnt base base-devel linux \
	 zsh sudo vim git wget \
	 dhcpcd \
	 networkmanager \
	 grub os-prober \
	 xorg-server lightdm lightdm-gtk-greeter \
	 gnome-terminal terminator cinnamon livecd-sounds \
	 firefox \
	 virtualbox-guest-utils
#+end_src

The problem with this approach is that is not easy to comment the function of each package. I also found an additional problem when the archlinux install image is old enough to prompt an error about gpg keyring. For this reason I started to use a different approach, like this:

#+begin_src bash :results verbatim
## Important: update package manager keyring before install packages
pacman -Syy --noconfirm archlinux-keyring


## Install System Elementary Packages
# esential packages
pacstrap /mnt base base-devel linux
# code editors
pacstrap /mnt vim nano
# system shell	
pacstrap /mnt zsh
# system shell additional functions
pacstrap /mnt pkgfile
# system tools	
pacstrap /mnt sudo git wget
# system tools for file system mounting
pacstrap /mnt gvfs
# system backup	
pacstrap /mnt rsync
# network package
pacstrap /mnt dhcpcd
# wifi package
pacstrap /mnt networkmanager
# boot loader	
pacstrap /mnt grub os-prober
# boot loader package to boot GRUB if UEFI mode
[[ ${boot_mode} == "UEFI" ]] && pacstrap /mnt efibootmgr	 
#+end_src

In the example above the overuse of pacstrap can be abusive, I am agree, but this way it looks more readable and maintainable too. Indeed, it is easy to note that an essential package is missing for Arch Linux installation in any real machine:

#+begin_src bash :results verbatim
pacstrap /mnt linux-firmware
#+end_src

# This list what is called "elementary packages", a minimun Arch Linux packages that allow to connect to internet, mount usb drivers, and make the boot loader to recognize other operating systems previously installed, like MS Windows, MacOS or even other Linux present. If you need to mount a HDD formated for MS Windows, you will need also other packages, such as:

# #+begin_src bash :results verbatim
# pacstrap /mnt ntfs-3g 
# #+end_src

- Pre-installation

  * 1.1-1.3 Prepare an installation image (out of the scope)
  * 1.4 Boot the live environment
  * 1.5 Set the console keyboard layout
  * 1.6 Verify the boot mode
  * 1.7 Connect to the internet
  * 1.8 Update the system clock
  * 1.9 Partition the disks
    * 1.9.1 Example layouts
  * 1.10 Format the partitions
  * 1.11 Mount the file systems

- Installation

  * 2.1 Select the mirrors
  * 2.2 Install essential packages

- Configure the system

  * 3.1 Fstab
  * 3.2 Chroot
  * 3.3 Time zone
  * 3.4 Localization
  * 3.5 Network configuration
  * 3.6 Initramfs
  * 3.7 Root password
  * 3.8 Boot loader

- Reboot
- Post-installation


# ** Why Arch Linux instead of many other Linux distritutions 

# The answer is simply, reproducibility and sharing!. But please, let me explain why:

# As a researcher, the scientific activity involves making scientific
# methods, data and outcomes available for everyone. Make science open
# and reproducible allow other scientist to replicate and adapt such
# methods to their own needs, contributions that summarized can be
# translated into a collaborative global progress.

# This contributive philosophy is also present in the open source
# operating system Linux, which source code is easily available for
# everyone. Anyone capable of coding can contribute, modify, enhance and
# distribute the code to anyone and for any purpose, with hundreds of distributions available.

# Linux beginner-friendly distributions provides a pre-configured system
# with packages that can be unnecessary, or designed for user data
# collection (e.g. Ubuntu and Canonical's commercial nature). On the
# other hand, Arch Linux offer a different and more functional approach.

# Arch Linux system can customize to fit specific needs, avoiding
# packages that can compromise sensitive data. Due to its minimalist
# design, an Arch Linux system can be easily reproduced and distributed
# to other users, by building an USB/CD ISO image or installed as a
# persistent live USB drive. Arch Linux require less space and memory
# resources than beginner-friendly distributions, facilitating to
# migrate a running Arch Linux to another machine, a KVM instance or a
# VirtualBox machine.
