#+startup: showeverything nohideblocks inlineimages
#+options: creator:nil author:nil toc:t date:t email:nil num:nil title:nil \n:t
#+title: README
#+date: <2022-01-03 Mon>
#+author: Ricardo A. O. Medina
#+email: raom2004@gmail.com
#+language: en
#+creator: Emacs 27.2 (Org mode 9.3.7)

* Arch Linux: automating installation scripts

Arch Linux is a minimalist and flexible Linux distribution which excellent documentation and high-quality packages allow users to design a highly customized system. A philosophy opposite to Linux beginner-friendly distributions which provides a pre-configured system with packages that are unnecessary or designed for user data collection (e.g. Ubuntu and Canonical's commercial nature).

#+HTML:<div align=center>
#+CAPTION: archlinux-Ubuntu/Canonical
#+NAME: Fig. 1
[[./.images/arch-linux-vs-ubuntu.png]]
#+HTML:</div>

Arch Linux philosophy encourage users to install packages that fulfill their unique needs, obtaining an incredibly powerful and lightweight system, easy to manage. However, the installation and configuration process can be challenging for beginners, specially when the documentation have not been extensively read. But what to do once a user has completed such process?

Well, *you can automatize the Arch Linux installation using the scripts described in this repository*, with tips and recommendations found in the documentation and forums, useful for: 
 - Everyone who has installed Arch Linux before and wants to automatize the process using scripts.
 - Someone who has not installed Arch Linux before but definitely wants to have a look over the commands required.
In both cases, this repository is definitely for you!

# Who may read this repository?

#  - Everyone who has installed Arch Linux before and wants to automatize the process using scripts? this repository is for you!

#  - Everyone who has not installed Arch Linux before but definitely wants to have a look over the commands required? this repository is also for you!

** Content
 #+begin_quote
 - [[Arch Linux - automated installation scripts - an easy example]]
 - [[Improving the automated installation scripts]]
   - [[Disk partitioning BIOS/MBR, BIOS/GPT, UEFI/GPT and their encryption]]
   - [[Packages installing with pacstrap and the importance of keyring update]]
   - [[TODO User data encryption]]
   - [[TODO System backup, user documents backup and system update]]
   - [[TODO Security and documents encryption]]
 #+end_quote

** Arch Linux - automated installation scripts - an easy example

The most easy example to automatize the Arch Linux install, requires 3 scripts with very well defined tasks:

The [[./script1.sh][script1.sh]] performs the critical pre-installation steps, such as:
  - Disk partitioning and formatting with =parted=
  - partitions mounting
  - Package installation with =pacstrap=

The [[./script2.sh][script2.sh]] setup the new Arch Linux system using =chroot=, to configure:
  - Locale and datetime
  - The keyboard keymap
  - The preferred shell, like =bash= or =zsh=
  - the initial ram filesystem, =initramfs=
  - User accounts, passwords and permissions, including =sudo=
  - The installation of the boot loader =grub=

The [[./script2.sh][script3.sh]] runs on *first desktop boot*, to setup:
  - The user configuration files (also known as =dotfiles=)
  - The desktop customizations itself

IMHO, this is the easiest approach to install Arch Linux using scripts. It is quite useful for *testing* and *debugging* new Arch Linux configurations, dotfiles and desktop customizations, preferably *inside a virtual machine* before a real Machine.

** Improving the automated installation scripts

Install Arch Linux in real machines usually need to address some advanced aspects, like disk partitioning according to the firmware available (UEFI, BIOS), partition tables (MBR, GPT), boot support for additional operative systems, user data or system encryption, and last but not least, Arch Linux backup and maintenance. 

In this regard, this chapter covers recomendations about:
- Disk partitioning BIOS/MBR, BIOS/GPT, UEFI/GPT and their encryption
- Installing packages with pacstrap and the importance of keyring update
- User data encryption
- How to make a backup of the entire system, and make it bootable too
- Arch Linux maintenance using maint


*** Disk partitioning BIOS/MBR, BIOS/GPT, UEFI/GPT and their encryption

This chapter cover the most standard disk partitioning tables using =parted= and the bootloader =GRUB=.

**** BIOS/MBR

Arch Linux, as any other linux distro, only precise one unique partition, the single root partition =/=.

The example of such BIOS/MBR disk partitioning, is:

#+begin_src bash :results verbatim
## HDD partitioning (BIOS/MBR)
parted -s /dev/sda mklabel msdos
parted -s -a optimal /dev/sda mkpart primary ext4 0% 100%
parted -s /dev/sda set 1 boot on

## HDD formating (-F: overwrite if necessary)
mkfs.ext4 -F /dev/sda1

## HDD mounting
mount /dev/sda1 /mnt 
#+end_src

**** BIOS/GPT

If you want to support BIOS/GPT, you will need some changes according to the boot loader, which in this case is GRUB:
- Change the table partitioning from =msdos= to =gpt=
- GPT require a BIOS boot partition (that don't require to be mounted)
- Replace the =boot= flag for =bios_grub=

The example of BIOS/GPT partitioning table, is:

#+begin_src bash :results verbatim
## HDD partitioning (BIOS/GPT)
parted -s /dev/sda mklabel gpt
parted -s -a optimal /dev/sda mkpart primary ext2 0% 2MiB
parted -s /dev/sda set 1 bios_grub on
parted -s -a optimal /dev/sda mkpart primary ext4 2MiB 100%

## HDD formating (-F: overwrite if necessary)
mkfs.ext4 -F /dev/sda2

## HDD mounting
# BIOS/GPT require space for the partition bios_grub
# but such boot partition don't require to be mounted
mount /dev/sda2 /mnt
#+end_src

**** UEFI/GPT

The UEFI/GPT partition table is similar to the previous, with just few modifications:
- Create a boot partition with fat32 as the file system type
- Replace the =bios_grub= flag for =esp=
- Install package =efibootmbr= with pacstrap

The example of UEFI/GPT partitioning table, is:

#+begin_src bash :results verbatim
## HDD partitioning (UEFI/GPT)
parted -s /dev/sda mklabel gpt
parted -s -a optimal /dev/sda mkpart primary 0% 512MiB
parted -s /dev/sda set 1 esp on
parted -s -a optimal /dev/sda mkpart primary 512MiB 100%

## HDD formating (-F: overwrite if necessary)
mkfs.fat -F32 /dev/sda1
mkfs.ext4 -F /dev/sda2

## HDD mounting
mount /dev/sda2 /mnt
mkdir -p /mnt/boot/efi
mount /dev/sda1 /mnt/boot/efi
#+end_src

#+begin_src bash :results verbatim
## package required for GRUB to boot in UEFI mode
if [[ ${boot_mode} == "UEFI" ]]; then
    pacstrap /mnt efibootmgr	 
fi
#+end_src

**** Disk partitioning, all together - BIOS/MBR, BIOS/GPT and UEFI/GPT

What happen when we want to support the options mentioned?. Well, Arch Linux can detect if it has booted from =BIOS= or =UEFI=, which can be quite useful to make a conditional like this:

#+begin_src bash :results verbatim
# BIOS and UEFI support
if ! ls /sys/firmware/efi/efivars >& /dev/null; then
    boot_mode="BIOS"
else
    boot_mode="UEFI"
fi


if [[ ${boot_mode} == "BIOS" ]]; then
    printf "BIOS detected! you can select a GPT or MBR partition table:\n"
    select OPTION in MBR GPT; do
	case ${OPTION} in
	    MBR)
		## HDD partitioning (BIOS/MBR)
		parted -s /dev/sda mklabel msdos
		parted -s -a optimal /dev/sda mkpart primary ext4 0% 100%
		parted -s /dev/sda set 1 boot on
		
		## HDD formating (-F: overwrite if necessary)
		mkfs.ext4 -F /dev/sda1

		## HDD mounting
		mount /dev/sda1 /mnt
		break
		;;
	    GPT)
		## HDD partitioning (BIOS/GPT)
		parted -s /dev/sda mklabel gpt
		parted -s -a optimal /dev/sda mkpart primary ext2 0% 2MiB
		parted -s /dev/sda set 1 bios_grub on
		parted -s -a optimal /dev/sda mkpart primary ext4 2MiB 100%
		
		## HDD formating (-F: overwrite if necessary)
		mkfs.ext4 -F /dev/sda2
		
		## HDD mounting
		mount /dev/sda2 /mnt
		break
		;;
	esac
    done
fi


if [[ ${boot_mode} == "UEFI" ]]; then
    ## HDD partitioning (UEFI/GPT)
    parted -s /dev/sda mklabel gpt
    parted -s -a optimal /dev/sda mkpart primary 0% 512MiB
    parted -s /dev/sda set 1 esp on
    parted -s -a optimal /dev/sda mkpart primary 512MiB 100%

    ## HDD formating (-F: overwrite if necessary)
    mkfs.fat -F32 /dev/sda1
    mkfs.ext4 -F /dev/sda2

    ## HDD mounting
    mount /dev/sda2 /mnt
    mkdir -p /mnt/boot/efi
    mount /dev/sda1 /mnt/boot/efi
fi

## package required for GRUB to boot in UEFI mode
if [[ ${boot_mode} == "UEFI" ]]; then
    pacstrap /mnt efibootmgr	 
fi
#+end_src

# The objective: 

# Install an Arch Linux system configuring dotfiles and desktop by bash scripts. 

# This text include how-to install Arch Linux in internal drive, but also in USB external removable media, called also USB persistent installation.

# How we will get there? Covering the next items:

# - Pre-installation, steps to prepare the new system
# - Installation, selecting the most relevant packages
# - Configuration, from file system table to boot loader config
# - Post-installation, using dotfiles and a lightweight desktop (xfce)

# Important: this text do not cover how-to prepare an installation
# medium like an USB flash drive, but you can find it [[https://wiki.archlinux.org/title/USB_flash_installation_medium][here]].

**** Advance disk partitioning - encrypted partitioning with LUKS LVM

After explain some examples of the most standard disk partitioning schemes, it is important to mentioned that disk partitioning can be completely encrypted. This specific item have been very well described [[https://www.rohlix.eu/post/linux-disk-encryption-with-bios-uefi-using-mbr-gpt-luks-lvm-and-grub/][here]].

In summary, this chapter described few but relevant aspects about the disk partitioning according to the boot loader =GRUB=. The disk partitioning tables described here works quite well, but you can add other partitions to these examples, taking extra care to avoid an Arch Linux install unable to boot.

The examples were made with the boot loader =GRUB= because it supports [[https://wiki.archlinux.org/title/Arch_boot_process#Boot_loader][almost everything]], like different firmwares, partition tables, multi-boot, file systems, RAID and LVM and their encryption, in addition to the documentation and forums available.

*** Installing packages with pacstrap and the importance of keyring update

The first pacstrap that I wrote, looked like this:

#+begin_src bash :results verbatim
## install system packages (with support for wifi and ethernet)
pacstrap /mnt base base-devel linux \
	 zsh sudo vim git wget \
	 dhcpcd \
	 networkmanager \
	 grub os-prober \
	 xorg-server lightdm lightdm-gtk-greeter \
	 gnome-terminal terminator cinnamon livecd-sounds \
	 firefox \
	 virtualbox-guest-utils
#+end_src

The problem with this approach is that is not easy to comment the function of each package. I also found an additional problem when the archlinux install image is old enough to prompt an error about gpg keyring. For this reason I started to use a different approach, like this:

#+begin_src bash :results verbatim
## Important: update package manager to avoid gpg keyrong errors
pacman -Syy --noconfirm archlinux-keyring


## Install System Elementary Packages
# esential packages
pacstrap /mnt base base-devel linux
# code editors
pacstrap /mnt vim nano
# system shell	
pacstrap /mnt zsh
# system shell additional functions
pacstrap /mnt pkgfile
# system tools	
pacstrap /mnt sudo git wget
# support for file system mounting
pacstrap /mnt gvfs
# system backup	
pacstrap /mnt rsync
# network package
pacstrap /mnt dhcpcd
# wifi package
pacstrap /mnt networkmanager
# boot loader	
pacstrap /mnt grub
# boot loader support for additional operative systems
pacstrap /mnt os-prober
# boot loader support to boot in UEFI mode (required for GRUB)
if [[ "${boot_mode}" == "UEFI" ]]; then
    pacstrap /mnt efibootmgr
fi
#+end_src

In the example above the repeated use of pacstrap can be abusive, but this way it looks more readable and maintainable too. Indeed, it is easy to note that an essential package is missing for Arch Linux installation in any real machine:

#+begin_src bash :results verbatim
pacstrap /mnt linux-firmware
#+end_src



# This list what is called "elementary packages", a minimun Arch Linux packages that allow to connect to internet, mount usb drivers, and make the boot loader to recognize other operating systems previously installed, like MS Windows, MacOS or even other Linux present. If you need to mount a HDD formated for MS Windows, you will need also other packages, such as:

# #+begin_src bash :results verbatim
# pacstrap /mnt ntfs-3g 
# #+end_src

*** User data encryption
*** How to make a backup of the entire system, and make it bootable too
*** Arch Linux maintenance using maint

